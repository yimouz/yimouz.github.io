<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>线程包括哪些状态，状态之间是如何变化</title>
      <link href="/2021/01/06/xian-cheng-bao-gua-na-xie-zhuang-tai-zhuang-tai-zhi-jian-shi-ru-he-bian-hua/"/>
      <url>/2021/01/06/xian-cheng-bao-gua-na-xie-zhuang-tai-zhuang-tai-zhi-jian-shi-ru-he-bian-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="线程包括哪些状态，状态之间是如何变化"><a href="#线程包括哪些状态，状态之间是如何变化" class="headerlink" title="线程包括哪些状态，状态之间是如何变化?"></a>线程包括哪些状态，状态之间是如何变化?</h1><h2 id="1-线程状态-六种状态"><a href="#1-线程状态-六种状态" class="headerlink" title="1. 线程状态-六种状态"></a>1. 线程状态-六种状态</h2><blockquote><p>线程的状态可以参考JDK中的Thread类中的枚举State,存在<strong>六种状态</strong></p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> {</span><br><span class="line"><span class="comment">//尚未启动的线程的线程状态</span></span><br><span class="line">  NEW,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//可运行线程的线程状态</span></span><br><span class="line">  RUNNABLE,</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程阻塞等待监视器锁的线程状态</span></span><br><span class="line">  BLOCKED,</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待线程的线程状态</span></span><br><span class="line">  WAITING,</span><br><span class="line"></span><br><span class="line"><span class="comment">//具有指定等待时间的等待线程的线程状态（有限等待）</span></span><br><span class="line">  TIMED_WAITING,</span><br><span class="line"></span><br><span class="line"> <span class="comment">//已终止线程的线程状态。线程已完成执行</span></span><br><span class="line">  TERMINATED;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://mmbiz.qpic.cn/mmbiz_png/fx1lx9ichONbR49V8p5731F4qVmNnVV2qoZzCfRibH4YDLa4kiaJ0rRYUyHhfTGahLUjRib5ocBvIvcibL095iab4Csw/640?wx_fmt=png&amp;from=appmsg" alt="img"></p><p><strong>六种状态介绍:</strong><img src="https://mmbiz.qpic.cn/mmbiz_png/fx1lx9ichONbR49V8p5731F4qVmNnVV2qhxZb2B0EeqsP1jMa3biaDuGb6XIfibBmwKaNqDP5wpxMpFMhPkSrciaHg/640?wx_fmt=png&amp;from=appmsg" alt="img"></p><p><strong>新建(NEW)</strong></p><blockquote><ul><li>当一个线程对象被创建，但还未调用 start 方法时处于<strong>新建</strong>状态</li><li>此时未与操作系统底层线程关联</li></ul></blockquote><p><strong>可运行(RUNNABLE)</strong>:</p><blockquote><ul><li>调用了 start 方法，就会由<strong>新建</strong>进入<strong>可运行</strong></li><li>此时与底层线程关联，由操作系统调度执行</li></ul></blockquote><p><strong>终结(TERMINATED)</strong></p><blockquote><ul><li>线程内代码已经执行完毕，由<strong>可运行</strong>进入<strong>终结</strong></li></ul></blockquote><blockquote><p>-此时会取消与底层线程关联</p></blockquote><p><strong>阻塞(BLOCKED)</strong></p><blockquote><ul><li>当获取锁失败后，由<strong>可运行</strong>进入 Monitor 的阻塞队列<strong>阻塞</strong>，此时不占用 cpu 时间</li><li>当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的<strong>阻塞</strong>线程，唤醒后的线程进入<strong>可运行</strong>状态</li></ul></blockquote><p><strong>等待(WAITING)</strong></p><blockquote><ul><li>当获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合<strong>等待</strong>，同样不占用 cpu 时间</li><li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>等待</strong>线程，恢复为<strong>可运行</strong>状态</li></ul></blockquote><p><strong>有时限等待(TIMED_WAITING)</strong></p><blockquote><ul><li>当获取锁成功后，但由于条件不满足，调用了 wait(long) 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合进行<strong>有时限等待</strong>，同样不占用 cpu 时间</li><li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>有时限等待</strong>线程，恢复为<strong>可运行</strong>状态，并重新去竞争锁</li><li>如果等待超时，也会从<strong>有时限等待</strong>状态恢复为<strong>可运行</strong>状态，并重新去竞争锁</li><li>还有一种情况是调用 sleep(long) 方法也会从<strong>可运行</strong>状态进入<strong>有时限等待</strong>状态，但与 Monitor 无关，不需要主动唤醒，超时时间到自然恢复为<strong>可运行</strong>状态</li></ul></blockquote><p><em><strong>其它情况（只需了解）</strong></em></p><blockquote><ul><li>可以用 interrupt() 方法打断<strong>等待</strong>、<strong>有时限等待</strong>的线程，让它们恢复为<strong>可运行</strong>状态</li><li>park，unpark 等方法也可以让线程等待和唤醒</li></ul></blockquote><h2 id="2-线程状态-五种状态"><a href="#2-线程状态-五种状态" class="headerlink" title="2. 线程状态-五种状态"></a>2. 线程状态-五种状态</h2><p><strong>五种状态的说法来自于操作系统层面的划分</strong><img src="https://mmbiz.qpic.cn/mmbiz_png/fx1lx9ichONbR49V8p5731F4qVmNnVV2qnDeczQhYd0GQu48ZDNXSLPqHAVopQXrFY0wiaR8DVMVfwiaqs6FTC5og/640?wx_fmt=png&amp;from=appmsg" alt="img"></p><blockquote><ul><li><p><strong>运行态</strong>：分到 cpu 时间，能真正执行线程内代码的</p></li><li><p><strong>就绪态</strong>：有资格分到 cpu 时间，但还未轮到它的</p></li><li><p><strong>阻塞态</strong>：没资格分到 cpu 时间的</p></li><li><ul><li>涵盖了 java 状态中提到的<strong>阻塞</strong>、<strong>等待</strong>、<strong>有时限等待</strong></li><li>多出了阻塞 I/O，指线程在调用阻塞 I/O 时，实际活由 I/O 设备完成，此时线程无事可做，只能干等</li></ul></li><li><p><strong>新建与终结态</strong>：与 java 中同名状态类似，不再啰嗦</p></li></ul></blockquote><h2 id="3-wait和sleep方法的不同？"><a href="#3-wait和sleep方法的不同？" class="headerlink" title="3. wait和sleep方法的不同？"></a>3. wait和sleep方法的不同？</h2><p><strong>共同点</strong></p><blockquote><p>wait() ，wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态</p></blockquote><p><strong>不同点</strong></p><p>1.方法归属不同</p><blockquote><ul><li>sleep(long) 是 Thread 的静态方法</li><li>而 wait()，wait(long) 都是 Object 的成员方法，每个对象都有 2.醒来时机不同</li><li>执行 sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来</li><li>wait(long) 和 wait() 还可以被 notify 唤醒，wait() 如果不唤醒就一直等下去</li><li>它们都可以被打断唤醒</li></ul></blockquote><ol><li>锁特性不同（重点）</li></ol><blockquote><ul><li>wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制</li><li>wait 方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃 cpu，但你们还可以用）</li><li>而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（我放弃 cpu，你们也用不了）</li></ul></blockquote><h2 id="3-线程状态面试题"><a href="#3-线程状态面试题" class="headerlink" title="3. 线程状态面试题"></a>3. 线程状态面试题</h2><p><strong>面试官</strong>：线程包括哪些状态，状态之间是如何变化的？</p><p><strong>候选人：</strong></p><blockquote><p>在JDK中的Thread类中的枚举State里面定义了6中线程的状态分别是：新建、可运行、终结、阻塞、等待和有时限等待六种。</p><p>关于线程的状态切换情况比较多。我分别介绍一下</p><p>当一个线程对象被创建，但还未调用 start 方法时处于<strong>新建</strong>状态，调用了 start 方法，就会由<strong>新建</strong>进入<strong>可运行</strong>状态。如果线程内代码已经执行完毕，由<strong>可运行</strong>进入<strong>终结</strong>状态。当然这些是一个线程正常执行情况。</p><p>如果线程获取锁失败后，由<strong>可运行</strong>进入 Monitor 的阻塞队列<strong>阻塞</strong>，只有当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的<strong>阻塞</strong>线程，唤醒后的线程进入<strong>可运行</strong>状态</p><p>如果线程获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从<strong>可运行</strong>状态释放锁<strong>等待</strong>状态，当其它持锁线程调用 notify() 或 notifyAll() 方法，会恢复为<strong>可运行</strong>状态</p><p>还有一种情况是调用 sleep(long) 方法也会从<strong>可运行</strong>状态进入<strong>有时限等待</strong>状态，不需要主动唤醒，超时时间到自然恢复为<strong>可运行</strong>状态</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 性能笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能笔记-几个瓶颈</title>
      <link href="/2020/05/26/xing-neng-bi-ji-ji-ge-ping-jing/"/>
      <url>/2020/05/26/xing-neng-bi-ji-ji-ge-ping-jing/</url>
      
        <content type="html"><![CDATA[<h1 id="性能测试的几个瓶颈术语"><a href="#性能测试的几个瓶颈术语" class="headerlink" title="性能测试的几个瓶颈术语"></a>性能测试的几个瓶颈术语</h1><h2 id="软件瓶颈"><a href="#软件瓶颈" class="headerlink" title="软件瓶颈"></a>软件瓶颈</h2><h3 id="应用软件瓶颈"><a href="#应用软件瓶颈" class="headerlink" title="应用软件瓶颈"></a>应用软件瓶颈</h3><p>web服务器包括数据库等中间件导致的响应时间增加</p><h3 id="应用程序瓶颈"><a href="#应用程序瓶颈" class="headerlink" title="应用程序瓶颈"></a>应用程序瓶颈</h3><p>处理问题只能串行不能并行导致的响应时间增加</p><h2 id="硬件瓶颈"><a href="#硬件瓶颈" class="headerlink" title="硬件瓶颈"></a>硬件瓶颈</h2><p>cpu ram 持续利用率过高超过95%</p><h2 id="操作系统瓶颈"><a href="#操作系统瓶颈" class="headerlink" title="操作系统瓶颈"></a>操作系统瓶颈</h2><p>例如win系虚拟内存的设置交互</p><h2 id="网络设备瓶颈"><a href="#网络设备瓶颈" class="headerlink" title="网络设备瓶颈"></a>网络设备瓶颈</h2><p>负载均衡 防火墙 交换机 相关</p>]]></content>
      
      
      <categories>
          
          <category> 性能测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用GIT远程仓管理hexo文档</title>
      <link href="/2020/05/22/shi-yong-git-yuan-cheng-cang-guan-li-hexo-wen-dang/"/>
      <url>/2020/05/22/shi-yong-git-yuan-cheng-cang-guan-li-hexo-wen-dang/</url>
      
        <content type="html"><![CDATA[<h3 id="Hexo简单的命令"><a href="#Hexo简单的命令" class="headerlink" title="Hexo简单的命令"></a>Hexo简单的命令</h3><ol><li>终端执行<code>hexo new 新文章</code>命令，此时本地<code>source/_post</code>目录下会新建<code>新文章.md</code>文件</li><li>打开 <code>新文章.md</code>编写完成后，终端执行<code>hexo g</code>编译</li><li>终端执行<code>hexo s</code>本地预览</li><li>终端执行<code>hexo d</code>推送到远程仓<strong>master</strong>分支</li></ol><h3 id="场景备份的建议"><a href="#场景备份的建议" class="headerlink" title="场景备份的建议"></a>场景备份的建议</h3><ul><li>个人pc比较多,有时候不是专门用一台机器来做一件事,公司家庭暂住地等等等等,多台pc的使用场景</li><li>硬盘损坏,</li><li>电脑丢失</li><li>如果你还算比较珍你的部落格,不管是什么情况,都建议进行备份,鸡蛋不在一个篮子里,有备自然无患<br>有些人选择新建一个远程仓来进行拉取上传,有些人选择每次用u盘热拷数据,而我选择在原来远程仓基础上新建一个分支进行源码上传,原因嘛,自然是怎么方便怎么来.</li></ul><h4 id="新建git分支"><a href="#新建git分支" class="headerlink" title="新建git分支"></a>新建git分支</h4><p>终端执行<code>git branch</code><br>查看分支情况,如果没有意外你只有一个<strong>master</strong>分支<br>终端执行<code>git checkout -b dev</code><br>创建并切换到<strong>dev</strong>分支,其中<strong>dev</strong>是你的自定义分支名<br>再次执行<code>git branch</code><br>你可以看到列出的分支包含<strong>dev/master</strong><br>当前分支带有*号</p><h4 id="发布时选择的分支"><a href="#发布时选择的分支" class="headerlink" title="发布时选择的分支"></a>发布时选择的分支</h4><p>github仓库初始化生成一个master分支，这没什么特殊含义,只是init的时候就叫这个而已.<br>不过这对hexo来讲,生成的静态页面也是默认在master分支,如非魔改框架,请务必留着.<br>我这里选择<strong>dev</strong>分支作为我的源码托管分支,<br>你可以在克隆项目的时候指定分支<code>git clone -b dev xxurl</code>如果你正好也感兴趣,我会在后面描述  </p><h4 id="本地与远程仓库关联"><a href="#本地与远程仓库关联" class="headerlink" title="本地与远程仓库关联"></a>本地与远程仓库关联</h4><p>终端执行<code class="shell  language-shell">git remote add origin <a href="mailto:git@github.com">git@github.com</a>:yimouz/yimouz.github.io.git</code>  </p><blockquote><p>这里的origin只是一个易标识,你可以修改,比如hexo,后面这一串是仓库ssh地址,请不要错误关联到我的仓库,错误关联但没有配对的密钥自然没有用.除了ssh还可以选择http方式,具体看你个人选择.</p></blockquote><h4 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h4><p>推送到dev分支。<br>本地有许多文件,保留文章跟一些你觉得重要的，其他无关的文件并不希望推送，<br>使用<code>.gitignore</code>文件吧<br>把这些不想要的推送的保存到你ignore,比如如下一些:<br>.DS_Store<br>Thumbs.db<br>db.json<br><em>.log<br>node_modules/<br>public/<br>.deploy</em>/<br>添加完就可以试一下推送了<br>终端执行：<br> </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m '你的提交信息'</span><br><span class="line">git push hexo dev</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="删除dev分支的某些文件"><a href="#删除dev分支的某些文件" class="headerlink" title="删除dev分支的某些文件"></a>删除dev分支的某些文件</h4><p>dev继承自master会带上master已经存在的分支内容<br>类似public<br>如果你跟我一样看着他们常常难受<br>不要犹豫,本地环境.<br>按下你的delete fireout it<br>删除完,终端执行<br>当然不删也可以<br> </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m '同样填写你的注释信息'</span><br><span class="line">git push hexo dev</span><br></pre></td></tr></tbody></table></figure><br>你会发现.ignore里携带的都没有带上去了.<br>这就是ignore<p></p><h3 id="多pc"><a href="#多pc" class="headerlink" title="多pc"></a>多pc</h3><p>回到这个问题,新电脑了怎么办,硬盘坏了怎么办  </p><ol><li>下载git </li><li>安装node npm </li><li>克隆你的分支<code>git clone -b dev 你的url</code>   </li><li>初始化init</li><li>密钥</li><li>关联到你的远程仓</li></ol><blockquote><p>当然不要忘记<br> </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo   </span><br><span class="line">npm install hexo-deployer-git -save</span><br></pre></td></tr></tbody></table></figure><br>是不是又回到了熟悉的环境<p></p></blockquote><h3 id="好了知道你有多pc使用习惯了-git就非常适合这种多端协作的场景-你要知道他是干嘛的"><a href="#好了知道你有多pc使用习惯了-git就非常适合这种多端协作的场景-你要知道他是干嘛的" class="headerlink" title="好了知道你有多pc使用习惯了,git就非常适合这种多端协作的场景,你要知道他是干嘛的"></a>好了知道你有多pc使用习惯了,git就非常适合这种多端协作的场景,你要知道他是干嘛的</h3><p>在公司划水,写写博客 一顿操作在push之后进入贤者模式<br>晚上或者周末在家,心潮澎拜,idea遍及<br>马不停蹄打开git</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/git pull &lt;远程仓ssh&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;   </span><br><span class="line"></span><br><span class="line">git pull git@github.com:yimouz/yimouz.github.io.git dev:dev</span><br><span class="line">/拉取并合并到你的本地环境  </span><br></pre></td></tr></tbody></table></figure><blockquote><p>至此就结束了!</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
