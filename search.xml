<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hexo 单仓库双分支 配合action</title>
      <link href="/2026/01/30/hexo-dan-cang-ku-shuang-fen-zhi-yun-xiao-ji/"/>
      <url>/2026/01/30/hexo-dan-cang-ku-shuang-fen-zhi-yun-xiao-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-单仓库双分支：摆脱本地hexo、node"><a href="#Hexo-单仓库双分支：摆脱本地hexo、node" class="headerlink" title="Hexo 单仓库双分支：摆脱本地hexo、node"></a>Hexo 单仓库双分支：摆脱本地hexo、node</h1><p>本方案旨在实现一个<strong>完全脱离本地环境</strong>、随时随地可写作的现代化博客系统。你只需要一个 GitHub 账号，即可通过网页或任何 Git 客户端发布文章。</p><h2 id="1-核心架构：单仓库双分支"><a href="#1-核心架构：单仓库双分支" class="headerlink" title="1. 核心架构：单仓库双分支"></a>1. 核心架构：单仓库双分支</h2><p>同一个 GitHub 仓库的两个分支，实现“源码”与“网页”的分离：</p><table><thead><tr><th align="left">分支名</th><th align="left">作用</th><th align="left">内容</th><th align="left">权限</th></tr></thead><tbody><tr><td align="left"><strong><code>dev</code></strong></td><td align="left"><strong>后台 (源码)</strong></td><td align="left">Markdown 文章、配置文件、<code>package.json</code></td><td align="left"><strong>默认分支</strong>，你在此写作</td></tr><tr><td align="left"><strong><code>master</code></strong></td><td align="left"><strong>前台 (网页)</strong></td><td align="left">HTML/CSS/JS (由 Action 自动生成)</td><td align="left">仅由 Robot 推送，<strong>勿手动修改</strong></td></tr></tbody></table><hr><h2 id="2-初始环境搭建-只需做一次"><a href="#2-初始环境搭建-只需做一次" class="headerlink" title="2. 初始环境搭建 (只需做一次)"></a>2. 初始环境搭建 (只需做一次)</h2><h3 id="第一步：准备仓库"><a href="#第一步：准备仓库" class="headerlink" title="第一步：准备仓库"></a>第一步：准备仓库</h3><ol><li> 在 GitHub 创建一个新仓库，名称必须为：<code>你的用户名.github.io</code>。</li><li> 仓库设置为 <strong>Public</strong>（公开）。</li></ol><h3 id="第二步：初始化分支"><a href="#第二步：初始化分支" class="headerlink" title="第二步：初始化分支"></a>第二步：初始化分支</h3><p>在本地或者直接在 GitHub 网页上操作：</p><ol><li> 确保你当前处于一个干净的分支（建议命名为 <code>dev</code>）。</li><li> 将 Hexo 源码（<code>source/</code>, <code>themes/</code>, <code>_config.yml</code>, <code>package.json</code> 等）全部推送到 <code>dev</code>。</li><li> 在 GitHub 仓库设置 (<strong>Settings -&gt; General</strong>) 中，将 <strong>Default branch</strong> 修改为 **<code>dev</code>**。</li><li> (可选) 删除远程的 <code>master</code> 分支（如果有），让 Action 稍后自动重建一个干净的。</li></ol><h3 id="第三步：配置自动化-GitHub-Actions"><a href="#第三步：配置自动化-GitHub-Actions" class="headerlink" title="第三步：配置自动化 (GitHub Actions)"></a>第三步：配置自动化 (GitHub Actions)</h3><p>在 <code>dev</code> 分支根目录下，创建文件 <code>.github/workflows/deploy.yml</code>：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">name</span><span class="token punctuation">:</span> Deploy Hexo Blog<span class="token key atrule">on</span><span class="token punctuation">:</span>  <span class="token key atrule">push</span><span class="token punctuation">:</span>    <span class="token key atrule">branches</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> dev  <span class="token comment"># 监听源码分支的变动</span><span class="token key atrule">permissions</span><span class="token punctuation">:</span>  <span class="token key atrule">contents</span><span class="token punctuation">:</span> write <span class="token comment"># 必须赋予写权限</span><span class="token key atrule">jobs</span><span class="token punctuation">:</span>  <span class="token key atrule">build</span><span class="token punctuation">:</span>    <span class="token key atrule">runs-on</span><span class="token punctuation">:</span> ubuntu<span class="token punctuation">-</span>latest    <span class="token key atrule">steps</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Checkout Source        <span class="token key atrule">uses</span><span class="token punctuation">:</span> actions/checkout@v4        <span class="token key atrule">with</span><span class="token punctuation">:</span>          <span class="token key atrule">ref</span><span class="token punctuation">:</span> dev          <span class="token comment"># 拉取源码</span>          <span class="token key atrule">submodules</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token comment"># 兼容主题 submodule</span>          <span class="token key atrule">fetch-depth</span><span class="token punctuation">:</span> <span class="token number">0</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Setup Node.js        <span class="token key atrule">uses</span><span class="token punctuation">:</span> actions/setup<span class="token punctuation">-</span>node@v4        <span class="token key atrule">with</span><span class="token punctuation">:</span>          <span class="token key atrule">node-version</span><span class="token punctuation">:</span> <span class="token string">'20'</span> <span class="token comment"># 使用现代 Node 版本</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Upgrade npm &amp; Install Hexo CLI        <span class="token key atrule">run</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string">          npm install -g npm@latest          npm install -g hexo-cli</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Install Dependencies        <span class="token key atrule">run</span><span class="token punctuation">:</span> npm install <span class="token punctuation">-</span><span class="token punctuation">-</span>no<span class="token punctuation">-</span>optional      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Build Hexo        <span class="token key atrule">run</span><span class="token punctuation">:</span> hexo generate      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Deploy to Master        <span class="token key atrule">uses</span><span class="token punctuation">:</span> peaceiris/actions<span class="token punctuation">-</span>gh<span class="token punctuation">-</span>pages@v3        <span class="token key atrule">with</span><span class="token punctuation">:</span>          <span class="token key atrule">github_token</span><span class="token punctuation">:</span> $<span class="token punctuation">{</span><span class="token punctuation">{</span> secrets.GITHUB_TOKEN <span class="token punctuation">}</span><span class="token punctuation">}</span>          <span class="token key atrule">publish_dir</span><span class="token punctuation">:</span> ./public          <span class="token key atrule">publish_branch</span><span class="token punctuation">:</span> master  <span class="token comment"># 发布到 master 分支</span>          <span class="token key atrule">commit_message</span><span class="token punctuation">:</span> <span class="token string">"Auto deploy: ${{ github.event.head_commit.message }}"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第四步：开启-GitHub-Pages"><a href="#第四步：开启-GitHub-Pages" class="headerlink" title="第四步：开启 GitHub Pages"></a>第四步：开启 GitHub Pages</h3><p>等待第一次 Action 跑通（显示绿色 ✅）后：</p><ol><li> 进入仓库 <strong>Settings -&gt; Pages</strong>。</li><li> <strong>Source</strong> 选择 <code>Deploy from a branch</code>。</li><li> <strong>Branch</strong> 选择 <code>master</code> 分支（根目录 <code>/root</code>）。</li><li> 保存。</li></ol><hr><h2 id="3-日常写作流程-完全云端化"><a href="#3-日常写作流程-完全云端化" class="headerlink" title="3. 日常写作流程 (完全云端化)"></a>3. 日常写作流程 (完全云端化)</h2><p>你可以选择以下任意一种方式写文章，<strong>无需本地安装 Node.js/Hexo</strong>。</p><h3 id="方式-A：GitHub-网页版-最简单"><a href="#方式-A：GitHub-网页版-最简单" class="headerlink" title="方式 A：GitHub 网页版 (最简单)"></a>方式 A：GitHub 网页版 (最简单)</h3><ol><li> 打开你的仓库首页（默认就是 <code>dev</code> 分支）。</li><li> 进入 <code>source/_posts/</code> 目录。</li><li> 点击 <strong>Add file -&gt; Create new file</strong>。</li><li>文件名填 <code>我的新文章.md</code>，内容写入： <pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token front-matter-block"><span class="token punctuation">---</span><span class="token front-matter yaml language-yaml"><span class="token key atrule">title</span><span class="token punctuation">:</span> 我的新文章<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2024-03-21 12:00:00</span><span class="token key atrule">tags</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>生活<span class="token punctuation">,</span> 记录<span class="token punctuation">]</span></span><span class="token punctuation">---</span></span>这里是正文内容...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li> 点击底部的 <strong>Commit changes</strong>。</li><li> <strong>完成！</strong> 等待 1-2 分钟，你的博客 <code>https://你的用户名.github.io</code> 就会自动更新。</li></ol><h3 id="方式-B：VS-Code-网页版"><a href="#方式-B：VS-Code-网页版" class="headerlink" title="方式 B：VS Code 网页版"></a>方式 B：VS Code 网页版</h3><ol><li> 在你的仓库页面，直接按键盘上的 <strong><code>.</code> (句号)</strong> 键。</li><li> 这会打开一个网页版的 VS Code 编辑器。</li><li> 像在本地一样写文章、管理文件。</li><li> 写完后在左侧 Git 栏提交并推送。</li></ol><hr><h2 id="4-避坑指南"><a href="#4-避坑指南" class="headerlink" title="4. 避坑指南"></a>4. 避坑指南</h2><ol><li><p><strong>依赖管理</strong>：</p><ul><li>  确保 <code>package.json</code> 里的 <code>hexo</code> 版本是新的（建议 <code>^7.0.0</code>）。</li><li>  <strong>不要上传</strong> <code>package-lock.json</code>（除非你很确定环境一致），让 Action 每次自己计算依赖，可以避免很多 npm 兼容性报错。</li></ul></li><li><p><strong>图片处理</strong>：</p><ul><li>  在网页端写文章时，上传图片比较麻烦。</li><li>  建议使用 <strong>图床</strong>（如 SM.MS, Imgur, 或自己搭建的 OSS），在文章里直接用 Markdown 链接 <code>![](图片URL)</code> 引用。</li></ul></li><li><p><strong>主题修改</strong>：</p><ul><li>  如果需要修改主题配置（如菜单、侧边栏），直接编辑 <code>_config.yml</code> 或主题目录下的配置文件并提交即可，Action 会自动重新编译生效。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程包括哪些状态，状态之间是如何变化</title>
      <link href="/2021/01/06/xian-cheng-bao-gua-na-xie-zhuang-tai-zhuang-tai-zhi-jian-shi-ru-he-bian-hua/"/>
      <url>/2021/01/06/xian-cheng-bao-gua-na-xie-zhuang-tai-zhuang-tai-zhi-jian-shi-ru-he-bian-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="线程包括哪些状态，状态之间是如何变化"><a href="#线程包括哪些状态，状态之间是如何变化" class="headerlink" title="线程包括哪些状态，状态之间是如何变化?"></a>线程包括哪些状态，状态之间是如何变化?</h1><h2 id="1-线程状态-六种状态"><a href="#1-线程状态-六种状态" class="headerlink" title="1. 线程状态-六种状态"></a>1. 线程状态-六种状态</h2><blockquote><p>线程的状态可以参考JDK中的Thread类中的枚举State,存在<strong>六种状态</strong></p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">  <span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">State</span> <span class="token punctuation">{</span><span class="token comment">//尚未启动的线程的线程状态</span>  <span class="token constant">NEW</span><span class="token punctuation">,</span>  <span class="token comment">//可运行线程的线程状态</span>  <span class="token constant">RUNNABLE</span><span class="token punctuation">,</span><span class="token comment">//线程阻塞等待监视器锁的线程状态</span>  <span class="token constant">BLOCKED</span><span class="token punctuation">,</span><span class="token comment">//等待线程的线程状态</span>  <span class="token constant">WAITING</span><span class="token punctuation">,</span><span class="token comment">//具有指定等待时间的等待线程的线程状态（有限等待）</span>  <span class="token constant">TIMED_WAITING</span><span class="token punctuation">,</span> <span class="token comment">//已终止线程的线程状态。线程已完成执行</span>  <span class="token constant">TERMINATED</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://r2.022032.xyz/yimouz/2026/01/2fdb8ef77376eb11c1cce6076e62efc7.png" alt="线程状态转换图"></p><p><strong>六种状态介绍:</strong></p><p><img src="https://r2.022032.xyz/yimouz/2026/01/839854b08e1175a7e13158bf2ec28662.png" alt="线程状态介绍"></p><p><strong>新建(NEW)</strong></p><blockquote><ul><li>当一个线程对象被创建，但还未调用 start 方法时处于<strong>新建</strong>状态</li><li>此时未与操作系统底层线程关联</li></ul></blockquote><p><strong>可运行(RUNNABLE)</strong>:</p><blockquote><ul><li>调用了 start 方法，就会由<strong>新建</strong>进入<strong>可运行</strong></li><li>此时与底层线程关联，由操作系统调度执行</li></ul></blockquote><p><strong>终结(TERMINATED)</strong></p><blockquote><ul><li>线程内代码已经执行完毕，由<strong>可运行</strong>进入<strong>终结</strong></li></ul></blockquote><blockquote><p>-此时会取消与底层线程关联</p></blockquote><p><strong>阻塞(BLOCKED)</strong></p><blockquote><ul><li>当获取锁失败后，由<strong>可运行</strong>进入 Monitor 的阻塞队列<strong>阻塞</strong>，此时不占用 cpu 时间</li><li>当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的<strong>阻塞</strong>线程，唤醒后的线程进入<strong>可运行</strong>状态</li></ul></blockquote><p><strong>等待(WAITING)</strong></p><blockquote><ul><li>当获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合<strong>等待</strong>，同样不占用 cpu 时间</li><li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>等待</strong>线程，恢复为<strong>可运行</strong>状态</li></ul></blockquote><p><strong>有时限等待(TIMED_WAITING)</strong></p><blockquote><ul><li>当获取锁成功后，但由于条件不满足，调用了 wait(long) 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合进行<strong>有时限等待</strong>，同样不占用 cpu 时间</li><li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>有时限等待</strong>线程，恢复为<strong>可运行</strong>状态，并重新去竞争锁</li><li>如果等待超时，也会从<strong>有时限等待</strong>状态恢复为<strong>可运行</strong>状态，并重新去竞争锁</li><li>还有一种情况是调用 sleep(long) 方法也会从<strong>可运行</strong>状态进入<strong>有时限等待</strong>状态，但与 Monitor 无关，不需要主动唤醒，超时时间到自然恢复为<strong>可运行</strong>状态</li></ul></blockquote><p><em><strong>其它情况（只需了解）</strong></em></p><blockquote><ul><li>可以用 interrupt() 方法打断<strong>等待</strong>、<strong>有时限等待</strong>的线程，让它们恢复为<strong>可运行</strong>状态</li><li>park，unpark 等方法也可以让线程等待和唤醒</li></ul></blockquote><h2 id="2-线程状态-五种状态"><a href="#2-线程状态-五种状态" class="headerlink" title="2. 线程状态-五种状态"></a>2. 线程状态-五种状态</h2><p><strong>五种状态的说法来自于操作系统层面的划分</strong></p><p><img src="https://r2.022032.xyz/yimouz/2026/01/b3acf16e360c62b80baaefbc49e9097b.png" alt="操作系统线程状态图"></p><blockquote><ul><li><p><strong>运行态</strong>：分到 cpu 时间，能真正执行线程内代码的</p></li><li><p><strong>就绪态</strong>：有资格分到 cpu 时间，但还未轮到它的</p></li><li><p><strong>阻塞态</strong>：没资格分到 cpu 时间的</p></li><li><ul><li>涵盖了 java 状态中提到的<strong>阻塞</strong>、<strong>等待</strong>、<strong>有时限等待</strong></li><li>多出了阻塞 I/O，指线程在调用阻塞 I/O 时，实际活由 I/O 设备完成，此时线程无事可做，只能干等</li></ul></li><li><p><strong>新建与终结态</strong>：与 java 中同名状态类似，不再啰嗦</p></li></ul></blockquote><h2 id="3-wait和sleep方法的不同？"><a href="#3-wait和sleep方法的不同？" class="headerlink" title="3. wait和sleep方法的不同？"></a>3. wait和sleep方法的不同？</h2><p><strong>共同点</strong></p><blockquote><p>wait() ，wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态</p></blockquote><p><strong>不同点</strong></p><p>1.方法归属不同</p><blockquote><ul><li>sleep(long) 是 Thread 的静态方法</li><li>而 wait()，wait(long) 都是 Object 的成员方法，每个对象都有 2.醒来时机不同</li><li>执行 sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来</li><li>wait(long) 和 wait() 还可以被 notify 唤醒，wait() 如果不唤醒就一直等下去</li><li>它们都可以被打断唤醒</li></ul></blockquote><ol><li>锁特性不同（重点）</li></ol><blockquote><ul><li>wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制</li><li>wait 方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃 cpu，但你们还可以用）</li><li>而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（我放弃 cpu，你们也用不了）</li></ul></blockquote><h2 id="3-线程状态面试题"><a href="#3-线程状态面试题" class="headerlink" title="3. 线程状态面试题"></a>3. 线程状态面试题</h2><p><strong>面试官</strong>：线程包括哪些状态，状态之间是如何变化的？</p><p><strong>候选人：</strong></p><blockquote><p>在JDK中的Thread类中的枚举State里面定义了6中线程的状态分别是：新建、可运行、终结、阻塞、等待和有时限等待六种。</p><p>关于线程的状态切换情况比较多。我分别介绍一下</p><p>当一个线程对象被创建，但还未调用 start 方法时处于<strong>新建</strong>状态，调用了 start 方法，就会由<strong>新建</strong>进入<strong>可运行</strong>状态。如果线程内代码已经执行完毕，由<strong>可运行</strong>进入<strong>终结</strong>状态。当然这些是一个线程正常执行情况。</p><p>如果线程获取锁失败后，由<strong>可运行</strong>进入 Monitor 的阻塞队列<strong>阻塞</strong>，只有当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的<strong>阻塞</strong>线程，唤醒后的线程进入<strong>可运行</strong>状态</p><p>如果线程获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从<strong>可运行</strong>状态释放锁<strong>等待</strong>状态，当其它持锁线程调用 notify() 或 notifyAll() 方法，会恢复为<strong>可运行</strong>状态</p><p>还有一种情况是调用 sleep(long) 方法也会从<strong>可运行</strong>状态进入<strong>有时限等待</strong>状态，不需要主动唤醒，超时时间到自然恢复为<strong>可运行</strong>状态</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 性能笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能笔记-几个瓶颈</title>
      <link href="/2020/05/26/xing-neng-bi-ji-ji-ge-ping-jing/"/>
      <url>/2020/05/26/xing-neng-bi-ji-ji-ge-ping-jing/</url>
      
        <content type="html"><![CDATA[<h1 id="性能测试的几个瓶颈术语"><a href="#性能测试的几个瓶颈术语" class="headerlink" title="性能测试的几个瓶颈术语"></a>性能测试的几个瓶颈术语</h1><h2 id="软件瓶颈"><a href="#软件瓶颈" class="headerlink" title="软件瓶颈"></a>软件瓶颈</h2><h3 id="应用软件瓶颈"><a href="#应用软件瓶颈" class="headerlink" title="应用软件瓶颈"></a>应用软件瓶颈</h3><p>web服务器包括数据库等中间件导致的响应时间增加</p><h3 id="应用程序瓶颈"><a href="#应用程序瓶颈" class="headerlink" title="应用程序瓶颈"></a>应用程序瓶颈</h3><p>处理问题只能串行不能并行导致的响应时间增加</p><h2 id="硬件瓶颈"><a href="#硬件瓶颈" class="headerlink" title="硬件瓶颈"></a>硬件瓶颈</h2><p>cpu ram 持续利用率过高超过95%</p><h2 id="操作系统瓶颈"><a href="#操作系统瓶颈" class="headerlink" title="操作系统瓶颈"></a>操作系统瓶颈</h2><p>例如win系虚拟内存的设置交互</p><h2 id="网络设备瓶颈"><a href="#网络设备瓶颈" class="headerlink" title="网络设备瓶颈"></a>网络设备瓶颈</h2><p>负载均衡 防火墙 交换机 相关</p>]]></content>
      
      
      <categories>
          
          <category> 性能笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用GIT远程仓管理hexo文档</title>
      <link href="/2020/05/22/shi-yong-git-yuan-cheng-cang-guan-li-hexo-wen-dang/"/>
      <url>/2020/05/22/shi-yong-git-yuan-cheng-cang-guan-li-hexo-wen-dang/</url>
      
        <content type="html"><![CDATA[<h3 id="Hexo简单的命令"><a href="#Hexo简单的命令" class="headerlink" title="Hexo简单的命令"></a>Hexo简单的命令</h3><ol><li> 终端执行<code>hexo new 新文章</code>命令，此时本地<code>source/_post</code>目录下会新建<code>新文章.md</code>文件</li><li> 打开 <code>新文章.md</code>编写完成后，终端执行<code>hexo g</code>编译</li><li> 终端执行<code>hexo s</code>本地预览</li><li> 终端执行<code>hexo d</code>推送到远程仓<strong>master</strong>分支</li></ol><h3 id="场景备份的建议"><a href="#场景备份的建议" class="headerlink" title="场景备份的建议"></a>场景备份的建议</h3><ul><li>个人pc比较多,有时候不是专门用一台机器来做一件事,公司家庭暂住地等等等等,多台pc的使用场景</li><li>硬盘损坏,</li><li>电脑丢失</li><li>如果你还算比较珍你的部落格,不管是什么情况,都建议进行备份,鸡蛋不在一个篮子里,有备自然无患<br>有些人选择新建一个远程仓来进行拉取上传,有些人选择每次用u盘热拷数据,而我选择在原来远程仓基础上新建一个分支进行源码上传,原因嘛,自然是怎么方便怎么来.</li></ul><h4 id="新建git分支"><a href="#新建git分支" class="headerlink" title="新建git分支"></a>新建git分支</h4><p>终端执行<code>git branch</code><br>查看分支情况,如果没有意外你只有一个<strong>master</strong>分支<br>终端执行<code>git checkout -b dev</code><br>创建并切换到<strong>dev</strong>分支,其中<strong>dev</strong>是你的自定义分支名<br>再次执行<code>git branch</code><br>你可以看到列出的分支包含<strong>dev/master</strong><br>当前分支带有*号</p><h4 id="发布时选择的分支"><a href="#发布时选择的分支" class="headerlink" title="发布时选择的分支"></a>发布时选择的分支</h4><p>github仓库初始化生成一个master分支，这没什么特殊含义,只是init的时候就叫这个而已.<br>不过这对hexo来讲,生成的静态页面也是默认在master分支,如非魔改框架,请务必留着.<br>我这里选择<strong>dev</strong>分支作为我的源码托管分支,<br>你可以在克隆项目的时候指定分支<code>git clone -b dev xxurl</code>如果你正好也感兴趣,我会在后面描述  </p><h4 id="本地与远程仓库关联"><a href="#本地与远程仓库关联" class="headerlink" title="本地与远程仓库关联"></a>本地与远程仓库关联</h4><p>终端执行<code class="shell  language-shell">git remote add origin <a href="mailto:git@github.com">git@github.com</a>:yimouz/yimouz.github.io.git</code>  </p><blockquote><p>这里的origin只是一个易标识,你可以修改,比如hexo,后面这一串是仓库ssh地址,请不要错误关联到我的仓库,错误关联但没有配对的密钥自然没有用.除了ssh还可以选择http方式,具体看你个人选择.</p></blockquote><h4 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h4><p>推送到dev分支。<br>本地有许多文件,保留文章跟一些你觉得重要的，其他无关的文件并不希望推送，<br>使用<code>.gitignore</code>文件吧<br>把这些不想要的推送的保存到你ignore,比如如下一些:<br>.DS_Store<br>Thumbs.db<br>db.json<br><em>.log<br>node_modules/<br>public/<br>.deploy</em>/<br>添加完就可以试一下推送了<br>终端执行：<br> </p><pre class="line-numbers language-none"><code class="language-none">git add .git commit -m '你的提交信息'git push hexo dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p></p><h4 id="删除dev分支的某些文件"><a href="#删除dev分支的某些文件" class="headerlink" title="删除dev分支的某些文件"></a>删除dev分支的某些文件</h4><p>dev继承自master会带上master已经存在的分支内容<br>类似public<br>如果你跟我一样看着他们常常难受<br>不要犹豫,本地环境.<br>按下你的delete fireout it<br>删除完,终端执行<br>当然不删也可以<br> </p><pre class="line-numbers language-none"><code class="language-none">git add .git commit -m '同样填写你的注释信息'git push hexo dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>你会发现.ignore里携带的都没有带上去了.<br>这就是ignore<p></p><h3 id="多pc"><a href="#多pc" class="headerlink" title="多pc"></a>多pc</h3><p>回到这个问题,新电脑了怎么办,硬盘坏了怎么办  </p><ol><li>下载git </li><li>安装node npm </li><li>克隆你的分支<code>git clone -b dev 你的url</code>   </li><li>初始化init</li><li>密钥</li><li>关联到你的远程仓</li></ol><blockquote><p>当然不要忘记<br> </p><pre class="line-numbers language-none"><code class="language-none">npm install hexo   npm install hexo-deployer-git -save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>是不是又回到了熟悉的环境<p></p></blockquote><h3 id="好了知道你有多pc使用习惯了-git就非常适合这种多端协作的场景-你要知道他是干嘛的"><a href="#好了知道你有多pc使用习惯了-git就非常适合这种多端协作的场景-你要知道他是干嘛的" class="headerlink" title="好了知道你有多pc使用习惯了,git就非常适合这种多端协作的场景,你要知道他是干嘛的"></a>好了知道你有多pc使用习惯了,git就非常适合这种多端协作的场景,你要知道他是干嘛的</h3><p>在公司划水,写写博客 一顿操作在push之后进入贤者模式<br>晚上或者周末在家,心潮澎拜,idea遍及<br>马不停蹄打开git</p><pre class="line-numbers language-none"><code class="language-none">/git pull &lt;远程仓ssh&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;   git pull git@github.com:yimouz/yimouz.github.io.git dev:dev/拉取并合并到你的本地环境  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>至此就结束了!</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
