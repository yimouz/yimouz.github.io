---

title: 线程包括哪些状态，状态之间是如何变化
date: 2021-01-06 14:12:36
tags: 线程池
categories: 性能笔记
author: 是啊蓁阿
summary: 线程包括哪些状态，状态之间是如何变化
  

---
# 线程包括哪些状态，状态之间是如何变化? 

## 1. 线程状态-六种状态

> 线程的状态可以参考JDK中的Thread类中的枚举State,存在**六种状态**

```java
  public enum State {
//尚未启动的线程的线程状态
  NEW,

  //可运行线程的线程状态
  RUNNABLE,

//线程阻塞等待监视器锁的线程状态
  BLOCKED,

//等待线程的线程状态
  WAITING,

//具有指定等待时间的等待线程的线程状态（有限等待）
  TIMED_WAITING,

 //已终止线程的线程状态。线程已完成执行
  TERMINATED;
}
```

![线程状态转换图](https://r2.022032.xyz/yimouz/2026/01/2fdb8ef77376eb11c1cce6076e62efc7.png)

**六种状态介绍:**

![线程状态介绍](https://r2.022032.xyz/yimouz/2026/01/839854b08e1175a7e13158bf2ec28662.png)

**新建(NEW)**

> - 当一个线程对象被创建，但还未调用 start 方法时处于**新建**状态
> - 此时未与操作系统底层线程关联

**可运行(RUNNABLE)**:

> - 调用了 start 方法，就会由**新建**进入**可运行**
> - 此时与底层线程关联，由操作系统调度执行

**终结(TERMINATED)**

> - 线程内代码已经执行完毕，由**可运行**进入**终结**

> -此时会取消与底层线程关联

**阻塞(BLOCKED)**

> - 当获取锁失败后，由**可运行**进入 Monitor 的阻塞队列**阻塞**，此时不占用 cpu 时间
> - 当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的**阻塞**线程，唤醒后的线程进入**可运行**状态

**等待(WAITING)**

> - 当获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从**可运行**状态释放锁进入 Monitor 等待集合**等待**，同样不占用 cpu 时间
> - 当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的**等待**线程，恢复为**可运行**状态

**有时限等待(TIMED_WAITING)**

> - 当获取锁成功后，但由于条件不满足，调用了 wait(long) 方法，此时从**可运行**状态释放锁进入 Monitor 等待集合进行**有时限等待**，同样不占用 cpu 时间
> - 当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的**有时限等待**线程，恢复为**可运行**状态，并重新去竞争锁
> - 如果等待超时，也会从**有时限等待**状态恢复为**可运行**状态，并重新去竞争锁
> - 还有一种情况是调用 sleep(long) 方法也会从**可运行**状态进入**有时限等待**状态，但与 Monitor 无关，不需要主动唤醒，超时时间到自然恢复为**可运行**状态

***其它情况（只需了解）***

> - 可以用 interrupt() 方法打断**等待**、**有时限等待**的线程，让它们恢复为**可运行**状态
> - park，unpark 等方法也可以让线程等待和唤醒

## 2. 线程状态-五种状态

**五种状态的说法来自于操作系统层面的划分**

![操作系统线程状态图](https://r2.022032.xyz/yimouz/2026/01/b3acf16e360c62b80baaefbc49e9097b.png)

> - **运行态**：分到 cpu 时间，能真正执行线程内代码的
>
> - **就绪态**：有资格分到 cpu 时间，但还未轮到它的
>
> - **阻塞态**：没资格分到 cpu 时间的
>
> - - 涵盖了 java 状态中提到的**阻塞**、**等待**、**有时限等待**
>   - 多出了阻塞 I/O，指线程在调用阻塞 I/O 时，实际活由 I/O 设备完成，此时线程无事可做，只能干等
>
> - **新建与终结态**：与 java 中同名状态类似，不再啰嗦

## 3. wait和sleep方法的不同？

**共同点**

> wait() ，wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态

**不同点**

1.方法归属不同

> - sleep(long) 是 Thread 的静态方法
> - 而 wait()，wait(long) 都是 Object 的成员方法，每个对象都有 2.醒来时机不同
> - 执行 sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来
> - wait(long) 和 wait() 还可以被 notify 唤醒，wait() 如果不唤醒就一直等下去
> - 它们都可以被打断唤醒

1. 锁特性不同（重点）

> - wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制
> - wait 方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃 cpu，但你们还可以用）
> - 而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（我放弃 cpu，你们也用不了）

## 3. 线程状态面试题

**面试官**：线程包括哪些状态，状态之间是如何变化的？

**候选人：**

> 在JDK中的Thread类中的枚举State里面定义了6中线程的状态分别是：新建、可运行、终结、阻塞、等待和有时限等待六种。
>
> 关于线程的状态切换情况比较多。我分别介绍一下
>
> 当一个线程对象被创建，但还未调用 start 方法时处于**新建**状态，调用了 start 方法，就会由**新建**进入**可运行**状态。如果线程内代码已经执行完毕，由**可运行**进入**终结**状态。当然这些是一个线程正常执行情况。
>
> 如果线程获取锁失败后，由**可运行**进入 Monitor 的阻塞队列**阻塞**，只有当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的**阻塞**线程，唤醒后的线程进入**可运行**状态
>
> 如果线程获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从**可运行**状态释放锁**等待**状态，当其它持锁线程调用 notify() 或 notifyAll() 方法，会恢复为**可运行**状态
>
> 还有一种情况是调用 sleep(long) 方法也会从**可运行**状态进入**有时限等待**状态，不需要主动唤醒，超时时间到自然恢复为**可运行**状态
